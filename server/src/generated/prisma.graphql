# THIS FILE HAS BEEN AUTO-GENERATED BY "PRISMA DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Person implements Node {
  id: ID!
  name: String!
  birth(where: YearWhereInput): Year
  death(where: YearWhereInput): Year
}

type Year implements Node {
  id: ID!
  val: Int!
  name: String!
  births(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person!]
  deaths(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person!]
}


#
# Other Types
#

type AggregatePerson {
  count: Int!
}

type AggregateYear {
  count: Int!
}

type BatchPayload {
  """
  The number of nodes that have been affected by the Batch operation.
  """
  count: Long!
}

"""
The `Long` scalar type represents non-fractional signed whole numeric values.
Long can represent values between -(2^63) and 2^63 - 1.
"""
scalar Long

type Mutation {
  createPerson(data: PersonCreateInput!): Person!
  createYear(data: YearCreateInput!): Year!
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updateYear(data: YearUpdateInput!, where: YearWhereUniqueInput!): Year
  deletePerson(where: PersonWhereUniqueInput!): Person
  deleteYear(where: YearWhereUniqueInput!): Year
  upsertPerson(where: PersonWhereUniqueInput!, create: PersonCreateInput!, update: PersonUpdateInput!): Person!
  upsertYear(where: YearWhereUniqueInput!, create: YearCreateInput!, update: YearUpdateInput!): Year!
  updateManyPersons(data: PersonUpdateInput!, where: PersonWhereInput!): BatchPayload!
  updateManyYears(data: YearUpdateInput!, where: YearWhereInput!): BatchPayload!
  deleteManyPersons(where: PersonWhereInput!): BatchPayload!
  deleteManyYears(where: YearWhereInput!): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

"""
An object with an ID
"""
interface Node {
  """
  The id of the object.
  """
  id: ID!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: String
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: String
}

"""
A connection to a list of items.
"""
type PersonConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [PersonEdge]!
  aggregate: AggregatePerson!
}

input PersonCreateInput {
  name: String!
  birth: YearCreateOneWithoutBirthsInput
  death: YearCreateOneWithoutDeathsInput
}

input PersonCreateManyWithoutBirthInput {
  create: [PersonCreateWithoutBirthInput!]
  connect: [PersonWhereUniqueInput!]
}

input PersonCreateManyWithoutDeathInput {
  create: [PersonCreateWithoutDeathInput!]
  connect: [PersonWhereUniqueInput!]
}

input PersonCreateWithoutBirthInput {
  name: String!
  death: YearCreateOneWithoutDeathsInput
}

input PersonCreateWithoutDeathInput {
  name: String!
  birth: YearCreateOneWithoutBirthsInput
}

"""
An edge in a connection.
"""
type PersonEdge {
  """
  The item at the end of the edge.
  """
  node: Person!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum PersonOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type PersonPreviousValues {
  id: ID!
  name: String!
}

type PersonSubscriptionPayload {
  mutation: MutationType!
  node: Person
  updatedFields: [String!]
  previousValues: PersonPreviousValues
}

input PersonSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [PersonSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [PersonSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: PersonWhereInput
}

input PersonUpdateInput {
  name: String
  birth: YearUpdateOneWithoutBirthsInput
  death: YearUpdateOneWithoutDeathsInput
}

input PersonUpdateManyWithoutBirthInput {
  create: [PersonCreateWithoutBirthInput!]
  connect: [PersonWhereUniqueInput!]
  disconnect: [PersonWhereUniqueInput!]
  delete: [PersonWhereUniqueInput!]
  update: [PersonUpdateWithWhereUniqueWithoutBirthInput!]
  upsert: [PersonUpsertWithWhereUniqueWithoutBirthInput!]
}

input PersonUpdateManyWithoutDeathInput {
  create: [PersonCreateWithoutDeathInput!]
  connect: [PersonWhereUniqueInput!]
  disconnect: [PersonWhereUniqueInput!]
  delete: [PersonWhereUniqueInput!]
  update: [PersonUpdateWithWhereUniqueWithoutDeathInput!]
  upsert: [PersonUpsertWithWhereUniqueWithoutDeathInput!]
}

input PersonUpdateWithoutBirthDataInput {
  name: String
  death: YearUpdateOneWithoutDeathsInput
}

input PersonUpdateWithoutDeathDataInput {
  name: String
  birth: YearUpdateOneWithoutBirthsInput
}

input PersonUpdateWithWhereUniqueWithoutBirthInput {
  where: PersonWhereUniqueInput!
  data: PersonUpdateWithoutBirthDataInput!
}

input PersonUpdateWithWhereUniqueWithoutDeathInput {
  where: PersonWhereUniqueInput!
  data: PersonUpdateWithoutDeathDataInput!
}

input PersonUpsertWithWhereUniqueWithoutBirthInput {
  where: PersonWhereUniqueInput!
  update: PersonUpdateWithoutBirthDataInput!
  create: PersonCreateWithoutBirthInput!
}

input PersonUpsertWithWhereUniqueWithoutDeathInput {
  where: PersonWhereUniqueInput!
  update: PersonUpdateWithoutDeathDataInput!
  create: PersonCreateWithoutDeathInput!
}

input PersonWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [PersonWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [PersonWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  name: String
  """
  All values that are not equal to given value.
  """
  name_not: String
  """
  All values that are contained in given list.
  """
  name_in: [String!]
  """
  All values that are not contained in given list.
  """
  name_not_in: [String!]
  """
  All values less than the given value.
  """
  name_lt: String
  """
  All values less than or equal the given value.
  """
  name_lte: String
  """
  All values greater than the given value.
  """
  name_gt: String
  """
  All values greater than or equal the given value.
  """
  name_gte: String
  """
  All values containing the given string.
  """
  name_contains: String
  """
  All values not containing the given string.
  """
  name_not_contains: String
  """
  All values starting with the given string.
  """
  name_starts_with: String
  """
  All values not starting with the given string.
  """
  name_not_starts_with: String
  """
  All values ending with the given string.
  """
  name_ends_with: String
  """
  All values not ending with the given string.
  """
  name_not_ends_with: String
  birth: YearWhereInput
  death: YearWhereInput
}

input PersonWhereUniqueInput {
  id: ID
}

type Query {
  persons(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person]!
  years(where: YearWhereInput, orderBy: YearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Year]!
  person(where: PersonWhereUniqueInput!): Person
  year(where: YearWhereUniqueInput!): Year
  personsConnection(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PersonConnection!
  yearsConnection(where: YearWhereInput, orderBy: YearOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): YearConnection!
  """
  Fetches an object given its ID
  """
  node("""
  The ID of an object
  """
  id: ID!): Node
}

type Subscription {
  person(where: PersonSubscriptionWhereInput): PersonSubscriptionPayload
  year(where: YearSubscriptionWhereInput): YearSubscriptionPayload
}

"""
A connection to a list of items.
"""
type YearConnection {
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  A list of edges.
  """
  edges: [YearEdge]!
  aggregate: AggregateYear!
}

input YearCreateInput {
  val: Int!
  name: String!
  births: PersonCreateManyWithoutBirthInput
  deaths: PersonCreateManyWithoutDeathInput
}

input YearCreateOneWithoutBirthsInput {
  create: YearCreateWithoutBirthsInput
  connect: YearWhereUniqueInput
}

input YearCreateOneWithoutDeathsInput {
  create: YearCreateWithoutDeathsInput
  connect: YearWhereUniqueInput
}

input YearCreateWithoutBirthsInput {
  val: Int!
  name: String!
  deaths: PersonCreateManyWithoutDeathInput
}

input YearCreateWithoutDeathsInput {
  val: Int!
  name: String!
  births: PersonCreateManyWithoutBirthInput
}

"""
An edge in a connection.
"""
type YearEdge {
  """
  The item at the end of the edge.
  """
  node: Year!
  """
  A cursor for use in pagination.
  """
  cursor: String!
}

enum YearOrderByInput {
  id_ASC
  id_DESC
  val_ASC
  val_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type YearPreviousValues {
  id: ID!
  val: Int!
  name: String!
}

type YearSubscriptionPayload {
  mutation: MutationType!
  node: Year
  updatedFields: [String!]
  previousValues: YearPreviousValues
}

input YearSubscriptionWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [YearSubscriptionWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [YearSubscriptionWhereInput!]
  """
  The subscription event gets dispatched when it's listed in mutation_in
  """
  mutation_in: [MutationType!]
  """
  The subscription event gets only dispatched when one of the updated fields names is included in this list
  """
  updatedFields_contains: String
  """
  The subscription event gets only dispatched when all of the field names included in this list have been updated
  """
  updatedFields_contains_every: [String!]
  """
  The subscription event gets only dispatched when some of the field names included in this list have been updated
  """
  updatedFields_contains_some: [String!]
  node: YearWhereInput
}

input YearUpdateInput {
  val: Int
  name: String
  births: PersonUpdateManyWithoutBirthInput
  deaths: PersonUpdateManyWithoutDeathInput
}

input YearUpdateOneWithoutBirthsInput {
  create: YearCreateWithoutBirthsInput
  connect: YearWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: YearUpdateWithoutBirthsDataInput
  upsert: YearUpsertWithoutBirthsInput
}

input YearUpdateOneWithoutDeathsInput {
  create: YearCreateWithoutDeathsInput
  connect: YearWhereUniqueInput
  disconnect: Boolean
  delete: Boolean
  update: YearUpdateWithoutDeathsDataInput
  upsert: YearUpsertWithoutDeathsInput
}

input YearUpdateWithoutBirthsDataInput {
  val: Int
  name: String
  deaths: PersonUpdateManyWithoutDeathInput
}

input YearUpdateWithoutDeathsDataInput {
  val: Int
  name: String
  births: PersonUpdateManyWithoutBirthInput
}

input YearUpsertWithoutBirthsInput {
  update: YearUpdateWithoutBirthsDataInput!
  create: YearCreateWithoutBirthsInput!
}

input YearUpsertWithoutDeathsInput {
  update: YearUpdateWithoutDeathsDataInput!
  create: YearCreateWithoutDeathsInput!
}

input YearWhereInput {
  """
  Logical AND on all given filters.
  """
  AND: [YearWhereInput!]
  """
  Logical OR on all given filters.
  """
  OR: [YearWhereInput!]
  id: ID
  """
  All values that are not equal to given value.
  """
  id_not: ID
  """
  All values that are contained in given list.
  """
  id_in: [ID!]
  """
  All values that are not contained in given list.
  """
  id_not_in: [ID!]
  """
  All values less than the given value.
  """
  id_lt: ID
  """
  All values less than or equal the given value.
  """
  id_lte: ID
  """
  All values greater than the given value.
  """
  id_gt: ID
  """
  All values greater than or equal the given value.
  """
  id_gte: ID
  """
  All values containing the given string.
  """
  id_contains: ID
  """
  All values not containing the given string.
  """
  id_not_contains: ID
  """
  All values starting with the given string.
  """
  id_starts_with: ID
  """
  All values not starting with the given string.
  """
  id_not_starts_with: ID
  """
  All values ending with the given string.
  """
  id_ends_with: ID
  """
  All values not ending with the given string.
  """
  id_not_ends_with: ID
  val: Int
  """
  All values that are not equal to given value.
  """
  val_not: Int
  """
  All values that are contained in given list.
  """
  val_in: [Int!]
  """
  All values that are not contained in given list.
  """
  val_not_in: [Int!]
  """
  All values less than the given value.
  """
  val_lt: Int
  """
  All values less than or equal the given value.
  """
  val_lte: Int
  """
  All values greater than the given value.
  """
  val_gt: Int
  """
  All values greater than or equal the given value.
  """
  val_gte: Int
  name: String
  """
  All values that are not equal to given value.
  """
  name_not: String
  """
  All values that are contained in given list.
  """
  name_in: [String!]
  """
  All values that are not contained in given list.
  """
  name_not_in: [String!]
  """
  All values less than the given value.
  """
  name_lt: String
  """
  All values less than or equal the given value.
  """
  name_lte: String
  """
  All values greater than the given value.
  """
  name_gt: String
  """
  All values greater than or equal the given value.
  """
  name_gte: String
  """
  All values containing the given string.
  """
  name_contains: String
  """
  All values not containing the given string.
  """
  name_not_contains: String
  """
  All values starting with the given string.
  """
  name_starts_with: String
  """
  All values not starting with the given string.
  """
  name_not_starts_with: String
  """
  All values ending with the given string.
  """
  name_ends_with: String
  """
  All values not ending with the given string.
  """
  name_not_ends_with: String
  births_every: PersonWhereInput
  births_some: PersonWhereInput
  births_none: PersonWhereInput
  deaths_every: PersonWhereInput
  deaths_some: PersonWhereInput
  deaths_none: PersonWhereInput
}

input YearWhereUniqueInput {
  id: ID
  val: Int
}
